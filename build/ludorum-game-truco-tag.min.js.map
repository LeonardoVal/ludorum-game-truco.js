{"version":3,"sources":["../src/__prologue__.js","../src/Truco.js","../src/ai/SubTruco.js","../src/__epilogue__.js"],"names":["__init__","base","Sermat","ludorum","declare","Game","raise","raiseIf","Iterable","iterable","exports","players","UserInterface","__package__","__name__","__dependencies__","__SERMAT__","include","ai","Truco","name","constructor","activePlayer","call","this","moves","result","next","haps","update","static __SERMAT__","identifier","serializer","obj","push","SubTruco","table","cardsHand","cardsFoot","length","cards","map","_","i","__tableResults__","r","Math","sign","tableResultSum","tableResults","victory","that","clone","move","splice","activatePlayers","opponent","slice","toChar","n","toString","join","static CARDS","static enumerateCards","It","product","apply","repeat","range","toArray","filter","sortedCards","sort","test"],"mappings":"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","file":"ludorum-game-truco-tag.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-truco',\n\t\t__name__: 'ludorum_game_truco',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] },\n\n\t\t/** The `ai` is the namespace used for functions and definitions relating to artificial\n\t\tintelligence.\n\t\t*/\n\t\tai: { }\n\t};\n","/** # Truco base\n\nBase abstract class for implementations of variants of the Truco card game.\n*/\nvar Truco = exports.Truco = declare(Game, {\n\tname: 'Truco',\n\n\t/** TODO\n\t*/\n\tconstructor: function Truco(activePlayer){\n\t\tGame.call(this, activePlayer);\n\t\t// initialization\n\t},\n\n\t/** The players' roles in a Truco match are `\"Hand\"` (_Mano_) and `\"Foot\"` (_Pie_).\n\t*/\n\tplayers: [\"Hand\", \"Foot\"],\n\n\t// ## Game logic ###############################################################################\n\n\t/** TODO\n\t*/\n\tmoves: function moves(){\n\t\treturn null;\n\t},\n\n\t/** TODO\n\t*/\n\tresult: function result() {\n\t\treturn null;\n\t},\n\n\t/** TODO\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\treturn null;\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Truco',\n\t\tserializer: function serialize_Mancala(obj) {\n\t\t\treturn [obj.activePlayer()];\n\t\t}\n\t}\n}); // declare Truco.\n\n// ## Truco type initialization ####################################################################\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Truco);\nSermat.include(exports);","/** # SubTruco\n\nSimplified version of the _truco_ subgame of the Truco card game, made to investigate the game.\n*/\n\nvar SubTruco = exports.ai.SubTruco = declare(Game, {\n\tname: 'SubTruco',\n\n\t/** The constructor takes:\n\t+ `table`: An array with the cards on the table,\n\t+ `cardsHand`: An array with the cards on the first player's hand,\n\t+ `cardsFoot`: An array with the cards on the second player's hand.\n\t*/\n\tconstructor: function SubTruco(table, cardsHand, cardsFoot) {\n\t\tGame.call(this, this.players[table.length % 2]);\n\t\tthis.table = table;\n\t\tthis.cardsHand = cardsHand;\n\t\tthis.cardsFoot = cardsFoot;\n\t},\n\n\t/** The players' roles in a Truco match are `\"Hand\"` (_Mano_) and `\"Foot\"` (_Pie_).\n\t*/\n\tplayers: [\"Hand\", \"Foot\"],\n\n\t// ## Game logic ###############################################################################\n\n\t/** A move for `SubTruco` is simply the index for the card to be played in the active player's\n\thand.\n\t*/\n\tmoves: function moves() {\n\t\tvar moves = this.result() ? null : {};\n\t\tif (moves) {\n\t\t\tvar cards = this.activePlayer() === 'Hand' ? this.cardsHand : this.cardsFoot;\n\t\t\tmoves[this.activePlayer()] = cards.map((_, i) => i);\n\t\t}\n\t\treturn moves;\n\t},\n\n\t/** The table results are the matches between the cards of each player in the table.\n\t*/\n\t__tableResults__: function __tableResults__() {\n\t\tvar r = [];\n\t\tfor (var i = 0; i < this.table.length; i += 2) {\n\t\t\tr.push(Math.sign(this.table[i] - this.table[i+1]));\n\t\t}\n\t\treturn r;\n\t},\n\n\t/** The round may end when both players have played two cards, if one player wins both card\n\tmatches or wins one with the other being tied. The round must end when both players have played\n\tall their three cards. If the last card match is tied, the player that won the first card match\n\twins. If all three card matches are tied, the _Hand_ player wins.\n\t*/\n\tresult: function result() {\n\t\tvar tableResults = this.__tableResults__(),\n\t\t\ttableResultSum;\n\t\tif (tableResults.length == 2) {\n\t\t\ttableResultSum = tableResults[0] + tableResults[1];\n\t\t\tif (tableResultSum > 0) {\n\t\t\t\treturn this.victory('Hand');\n\t\t\t} else if (tableResultSum < 0) {\n\t\t\t\treturn this.victory('Foot');\n\t\t\t}\n\t\t} else if (tableResults.length === 3) {\n\t\t\ttableResultSum = tableResults[0] + tableResults[1] + tableResults[2];\n\t\t\tif (tableResultSum > 0 || tableResultSum === 0 && tableResults[0] >= 0) {\n\t\t\t\treturn this.victory('Hand');\n\t\t\t} else if (tableResultSum < 0 || tableResultSum === 0 && tableResults[0] < 0) {\n\t\t\t\treturn this.victory('Foot');\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\t/** TODO\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\tbase.raiseIf(this.result(), \"Game is finished!\");\n\t\tvar that = update ? this : this.clone(),\n\t\t\tactivePlayer = this.activePlayer(),\n\t\t\tmove = +moves[activePlayer],\n\t\t\tcards = that['cards'+ activePlayer];\n\t\tbase.raiseIf(move < 0 || move >= cards.length, 'Invalid move ', move, 'at', that, '!');\n\t\tthat.table.push(cards[move]);\n\t\tcards.splice(move, 1);\n\t\tthat.activatePlayers(this.opponent());\n\t\treturn that;\n\t},\n\n\t// ## Utility methods #########################################################################\n\n\tclone: function clone() {\n\t\treturn new this.constructor(this.table.slice(), this.cardsHand.slice(),\n\t\t\tthis.cardsFoot.slice());\n\t},\n\n\t/** The string `identifier` for a `SubTruco` state always has 7 characters. The first one\n\tindicates the number of cards on the table. Then come the cards on the table, each encoded as\n\ta character (base 36). After that come the cards of the _Hand_ player, and finally the ones of\n\tthe _Foot_ player, both encoded in the same way as the cards on the table.\n\t*/\n\tidentifier: function identifier() {\n\t\tvar toChar = (n) => (n - 1).toString(36);\n\t\treturn this.table.length + this.table.map(toChar).join('') +\n\t\t\tthis.cardsHand.map(toChar).join('') +\n\t\t\tthis.cardsFoot.map(toChar).join('');\n\t},\n\n\t/** For this game suits are relevant only in the case of the sevens and the aces. Hence, cards\n\tare encoded using numbers from 1 to 14. How each number may map to a given card is defined in\n\t`CARDS`. Here the french deck's suits are used instead of the spanish deck's ones (because the\n\tlatter are not supported by Unicode). Spades and clubs are the same, diamonds are used for\n\tgolds and hearts for cups.\n\t*/\n\t'static CARDS': [\n\t\t[],                    //  0: Invalid.\n\t\t['4♦','4♥','4♠','4♣'], //  1: All fours.\n\t\t['5♦','5♥','5♠','5♣'], //  2: All fives.\n\t\t['6♦','6♥','6♠','6♣'], //  3: All sixes.\n\t\t['7♥','7♣'],           //  4: Sevens of hearts (cups) and clubs.\n\t\t['A♦','A♥','A♠','A♣'], //  5: All jacks (10s).\n\t\t['B♦','B♥','B♠','B♣'], //  6: All knights (11s).\n\t\t['C♦','C♥','C♠','C♣'], //  7: All kings (12s).\n\t\t['1♦','1♥'],           //  8: Aces of diamonds (golds) and hearts (cups).\n\t\t['2♦','2♥','2♠','2♣'], //  9: All twos.\n\t\t['3♦','3♥','3♠','3♣'], // 10: All threes.\n\t\t['7♦'],                // 11: Seven of diamonds (golds).\n\t\t['7♠'],                // 12: Seven of spades.\n\t\t['1♣'],                // 13: Ace of clubs.\n\t\t['1♠']                 // 14: Ace of spades.\n\t],\n\n\t/** The `enumerateCards` function returns an iterable of all possible hands for `SubTruco`. The\n\torder of the cards in each players' hand is not relevant. The amount of possible cards is\n\tchecked by means of a regular expression.\n\t*/\n\t'static enumerateCards': function enumerateCards() {\n\t\tvar It = base.Iterable,\n\t\t\tbaseSequence = It.product.apply(It, It.repeat(It.range(1,14), 6).toArray());\n\t\treturn baseSequence.filter(function (cards) {\n\t\t\tcards = cards.map((n) => n.toString(36));\n\t\t\tvar cardsHand = cards.slice(0, 3),\n\t\t\t\tcardsFoot = cards.slice(3, 6),\n\t\t\t\tsortedCards = cards.sort().join(''),\n\t\t\t\tamountsRegExp = /([1235679a])\\1{4,}|444+|888+|bb+|cc+|dd+|ee+/;\n\t\t\treturn cardsHand.join('') === cardsHand.sort().join('') &&\n\t\t\t\tcardsFoot.join('') === cardsFoot.sort().join('') &&\n\t\t\t\t!amountsRegExp.test(sortedCards);\n\t\t}, function (cards) {\n\t\t\treturn [cards.slice(0,3), cards.slice(3,6)];\n\t\t});\n\t},\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.SubTruco',\n\t\tserializer: function serialize_SubTruco(obj) {\n\t\t\treturn [obj.table, obj.cardsHand, obj.cardsFoot];\n\t\t}\n\t}\n}); // declare Truco.\n\n// ## SubTruco type initialization #################################################################\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(SubTruco);\nSermat.include(exports);","// See __prologue__.js\n\tSermat.include(exports);\n\t\n\treturn exports;\n}\n"]}