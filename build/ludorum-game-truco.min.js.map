{"version":3,"sources":["../src/__prologue__.js","../src/common.js","../src/Truco.js","../src/ai/SubTruco.js","../src/__epilogue__.js"],"names":["__init__","base","Sermat","ludorum","declare","Game","raise","raiseIf","Iterable","iterable","exports","players","UserInterface","__package__","__name__","__dependencies__","__SERMAT__","include","ai","generateMoves","cards","moves","i","length","push","arrEq","a","b","Truco","name","constructor","activePlayer","call","this","result","next","haps","update","static __SERMAT__","identifier","serializer","obj","SubTruco","cardsHand","cardsFoot","table","winner","result_parcial","victory","clone","that","slice","cartaATirar","move","splice","partialWinner","opponent","activatePlayers","par"],"mappings":"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","file":"ludorum-game-truco.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-truco',\n\t\t__name__: 'ludorum_game_truco',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] },\n\n\t\t/** The `ai` is the namespace used for functions and definitions relating to artificial\n\t\tintelligence.\n\t\t*/\n\t\tai: { }\n\t};\n","/** # Common functions and utilities.\n\nTODO\n*/\n\n/**\n * A card move is represented by an object with a player (who throws the card)\n * and a number, which is the index of the thrown card\n *\n * Note that cards are sorted in ascending order so index is consistent\n */\n\n/**\n * Funcion que recibe por parametro la mano actual de un jugador, y retorna los posibles movimientos.\n */\n\nfunction generateMoves(cards) {\n    var moves = [];\n    for (var i = 0; i < cards.length; i++) {\n        moves.push(i);\n    }\n    return moves;\n}\n\nfunction arrEq(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length != b.length) return false;\n\n    // If you don't care about the order of the elements inside\n    // the array, you should sort both arrays here.\n\n    for (var i = 0; i < a.length; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }","/** # Truco base\n\nBase abstract class for implementations of variants of the Truco card game.\n*/\nvar Truco = exports.Truco = declare(Game, {\n\tname: 'Truco',\n\n\t/** TODO\n\t*/\n\tconstructor: function Truco(activePlayer){\n\t\tGame.call(this, activePlayer);\n\t\t// initialization\n\t},\n\n\t/** The players' roles in a Truco match are `\"Hand\"` (_Mano_) and `\"Foot\"` (_Pie_).\n\t*/\n\tplayers: [\"Hand\", \"Foot\"],\n\n\t// ## Game logic ###############################################################################\n\n\t/** TODO\n\t*/\n\tmoves: function moves(){\n\t\treturn null;\n\t},\n\n\t/** TODO\n\t*/\n\tresult: function result() {\n\t\treturn null;\n\t},\n\n\t/** TODO\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\treturn null;\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Truco',\n\t\tserializer: function serialize_Mancala(obj) {\n\t\t\treturn [obj.activePlayer()];\n\t\t}\n\t}\n}); // declare Truco.\n\n// ## Truco type initialization ####################################################################\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Truco);\nSermat.include(exports);","/** # SubTruco\n\nSimplified version of the _truco_ subgame of the Truco card game, made to investigate the game.\n*/\n\n// TODO: Calcular tiempo que toma MiniMaxPlayer NO ALPHA BETA\n\nvar SubTruco = exports.ai.SubTruco = declare(Game, {\n\tname: 'Truco',\n\n\t/** TODO\n\t*/\n\tconstructor: function SubTruco(activePlayer, cardsHand, cardsFoot) {\n\t\tGame.call(this, activePlayer);\n\n\t\tthis.table = [];\n\t\tthis.cardsHand = cardsHand;\n\t\tthis.cardsFoot = cardsFoot;\n\n\t\tthis.winner = null;\n\n\t\t// 1 for the Hand, -1 for Foot\n\t\tthis.result_parcial = [];\n\t},\n\n\t/** The players' roles in a Truco match are `\"Hand\"` (_Mano_) and `\"Foot\"` (_Pie_).\n\t*/\n\tplayers: [\"Hand\", \"Foot\"],\n\n\t// ## Game logic ###############################################################################\n\n\t/** TODO\n\t * Devuelve un objeto de los movimientos posibles para los jugadores activo\n\t *\n\t * En este caso da las cartas que pueden ser tiradas.\n\t *\n\t * e.g. { \"Hand\": [{player: \"Hand\", card: 0}, {player: \"Hand\", card: 1}]}\n\t*/\n\tmoves: function moves() { // { player: [move]}\n\t\tif (!this.result()) {\n\t\t\tvar moves = {};\n\t\t\tif (this.activePlayer() === \"Hand\") {\n\t\t\t\tmoves[this.activePlayer()] = generateMoves(this.cardsHand);\n\t\t\t} else {\n\t\t\t\tmoves[this.activePlayer()] = generateMoves(this.cardsFoot);\n\t\t\t}\n\t\t\treturn moves;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/** TODO\n\t*/\n\tresult: function result() {\n\t\tif (this.winner) {\n\t\t\treturn this.victory(this.winner);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\tclone: function clone() {\n\t\tvar that = new SubTruco(this.activePlayer(), this.cardsHand.slice(), this.cardsFoot.slice());\n\t\tthat.table = this.table.slice();\n\t\tthat.winner = this.winner;\n\t\tthat.result_parcial = this.result_parcial.slice();\n\t\treturn that;\n\t},\n\n\t/** TODO\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\tvar that = update ? this : this.clone();\n\t\tif (that.winner) {\n\t\t\treturn that;\n\t\t}\n\n\t\tvar move = moves[this.activePlayer()];\n\t\tvar cartaATirar;\n\n\t\tif (that.activePlayer() === \"Hand\") {\n\t\t\tcartaATirar = that.cardsHand[move];\n\t\t\tthat.cardsHand.splice(move, 1);\n\t\t\tthat.table.push(cartaATirar);\n\t\t\t// Quitar de la mano del jugador una carta y ponerla en la mesa\n\n\t\t} else {\n\t\t\tcartaATirar = that.cardsFoot[move];\n\t\t\tthat.cardsFoot.splice(move, 1);\n\t\t\tthat.table.push(cartaATirar);\n\n\t\t\t//Comparar cartas en la mesa con la del mano, y ver quien gano la jugada parcial\n\t\t\tswitch (that.cardsFoot.length) {\n\t\t\t\tcase 2:\n\t\t\t\t\tthat.result_parcial[0] = that.table[0] > that.table[1] ? 1 : (that.table[0] == that.table[1] ? 0 : -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthat.result_parcial[1] = that.table[2] > that.table[3] ? 1 : (that.table[2] == that.table[3] ? 0 : -1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tthat.result_parcial[2] = that.table[4] > that.table[5] ? 1 : (that.table[4] == that.table[5] ? 0 : -1);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthat.winner = that.partialWinner();\n\t\t}\n\n\t\tvar opponent = that.activePlayer() === 'Hand' ? 'Foot' : 'Hand';\n\t\tthat.activatePlayers(opponent);\n\n\n\t\treturn that;\n\t},\n\n\tpartialWinner: function partialWinner() {\n\t\t// SIN EMPATE: gana el que haya ganado 2 manos\n\t\t// PARDA 1ra: gana segunda\n\t\t// PARDA 2da: gana primera\n\t\t// PARDA 3ra: gana primera\n\t\t// PARDA 1ra y 2da: gana tercera\n\t\t// PARDA 1ra 2da y 3ra: gana la mano\n\n\t\tvar par = this.result_parcial;\n\n\n\t\tif (par.length > 1) {\n\t\t\tif (par.length == 2) {\n\t\t\t\tif (arrEq(par, [1, 1]) || arrEq(par, [0, 1]) || arrEq(par, [1, 0])) {\n\t\t\t\t\treturn \"Hand\";\n\t\t\t\t} else if (arrEq(par, [-1, -1]) || arrEq(par, [0, -1]) || arrEq(par, [-1, 0])) {\n\t\t\t\t\treturn \"Foot\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (arrEq(par, [1, -1, 1]) || arrEq(par, [1, -1, 0]) || arrEq(par, [0, 0, 0]) || arrEq(par, [0, 0, 1]) || arrEq(par, [-1, 1, 1])) {\n\t\t\t\t\treturn \"Hand\";\n\t\t\t\t} else if (arrEq(par, [-1, 1, -1]) || arrEq(par, [-1, 1, 0]) || arrEq(par, [0, 0, -1]) || arrEq(par, [1, -1, -1])) {\n\t\t\t\t\treturn \"Foot\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.SubTruco',\n\t\tserializer: function serialize_Mancala(obj) {\n\t\t\treturn [obj.activePlayer(), obj.cardsHand, obj.cardsFoot, obj.table];\n\t\t}\n\t}\n}); // declare Truco.\n\n// ## Truco type initialization ####################################################################\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(SubTruco);\nSermat.include(exports);","// See __prologue__.js\n\tSermat.include(exports);\n\t\n\treturn exports;\n}\n"]}